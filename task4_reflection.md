## Задание по рефлексии 

Проектирование и реализация мультиагентной системы Study Assistant стали для меня полезным опытом работы с современными инструментами LangChain и LangGraph.

### Что сработало хорошо

1. Дизайн и логика handoff
   
   Паттерн Router + Specialized Agents оказался очень удачным выбором. Классификация запросов роутером на основе простого LLM-промпта дала почти 100% точность на тестовом наборе. Передача управления (handoff) через conditional_edges в LangGraph получилась чистой, предсказуемой и легко читаемой. Линейный поток без циклов упростил отладку и сделал поведение системы прозрачным.

2. Использование инструментов (tool calling)
   
    Инструменты вызываются осмысленно и только когда действительно нужны:
    - search_knowledge_base помогает теории,
    - execute_python_code автоматически тестирует генерируемый код,
    - create_study_plan создаёт структурированный план.
    Это значительно повышает практическую ценность ответов Code- и Planner-агентов.

3. Управление памятью
   
   Простая реализация SessionMemorySystem с ограничением в 20 взаимодействий и передачей контекста последних 2 сообщений в промпты агентов работает стабильно. Пользователь видит статистику сессии, а агенты могут учитывать предыдущий диалог — это уже даёт ощущение «живого» помощника.

## Неожиданное поведение и ошибки

1. Классификация роутера
   
    Иногда на граничных запросах (например, «Как написать код для сортировки массива?») роутер выбирал theory вместо code. Проблема решается уточнением промпта и примерами, но показывает, что роутер всё ещё чувствителен к формулировкам.

2. Вызов инструментов

    В некоторых случаях Code-агент генерирует код, но из-за отсутствия правильного Markdown-форматирования (блока ```python) инструмент выполнения кода не запускается, и пользователь не видит результат работы кода.

3. Память
   
   Текущая реализация передаёт только последние 2 взаимодействия и только в виде краткого списка. При длинных сессиях контекст теряется, и агенты не могут ссылаться на более ранние детали.

### Как можно развивать систему дальше?

1. Добавление Supervisor-агента
   
    Введение supervising-агента, который мог бы проверять ответы специализированных агентов, просить уточнения или перераспределять задачу другому агенту (например, если теория требует кода — передать Code-агенту).

2. Более глубокая память

    Переход на векторное хранилище (например, FAISS или Chroma) с RAG-подходом: сохранять ключевые факты из диалога и извлекать релевантные при новом запросе.

3. Новые инструменты

    - Поиск в интернете (Tavily или аналог) для актуальной информации.
    - Доступ к файловой системе пользователя (чтение/анализ кода проектов).
    - Генерация и отображение диаграмм (matplotlib → изображение).

4. Сложные паттерны взаимодействия

    Реализация Planner-Executor: Planner создаёт план из нескольких шагов, а Executor (возможно, в цикле) выполняет их по очереди с возможностью коррекции.

5. Улучшение надёжности

    Добавление fallback-логики: если роутер не уверен (низкая уверенность в ответе), направлять запрос в General-агент или запрашивать уточнение у пользователя.

## Итог
Система получилась рабочей, модульной и демонстрирует основные принципы современных мультиагентных архитектур на LangGraph. Основные цели лабораторной работы достигнуты: реализованы роутинг, специализированные агенты, tool calling и базовая память. При этом остаётся большой потенциал для развития в сторону более интеллектуального, контекстно-осознающего и интерактивного помощника.
Работа над проектом дала полное понимание того, как правильно проектировать агентов, управлять состоянием и делать их взаимодействие предсказуемым и полезным для пользователя.
